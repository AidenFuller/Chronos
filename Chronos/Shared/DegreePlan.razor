@inject DegreeCourseService DegreeCourseService
@inject DegreeService DegreeService
@inject CourseService CourseService 
@inject MajorCourseService MajorCourseService  

<div style="width: 100%; height: 100%" class="degreeplan">
    <CascadingValue Value="this">
        @if (BlockedCourses == null)
        {
            <p>Loading...</p>
        }
        else
        {
            for (int j = 0; j < (BlockedCourses.Count + 1) / BlocksPerYear; j++)
            {
                <div style="display: block;">
                    @for (int i = 0; i < BlocksPerYear; i++)
                    {
                        if (i + (j * BlocksPerYear) >= BlockedCourses.Count)
                        {
                            continue;
                        }

                        <div style="display: inline-block; width: @($"{100/BlocksPerYear}%"); height: 150px;" class="year-row">
                            
                            @* Assuming Semesters *@
                            
                            @if (i == 0)
                            {
                                <TileSlot Tiles="@BlockedCourses[i+(j*BlocksPerYear)]" BlockType=@Models.Enums.CourseRuntime.Semester1 />
                            }
                            else
                            {
                                <TileSlot Tiles="@BlockedCourses[i+(j*BlocksPerYear)]" BlockType=@Models.Enums.CourseRuntime.Semester2 />
                            }

                        </div>
                    }
                </div>
            }
        }
    </CascadingValue>
</div>


@code {
    [Parameter] public int BlocksPerYear { get; set; } = 2;
    [Parameter] public int UnitsPerBlock { get; set; } = 40;
    [Parameter] public int DegreeID { get; set; }
    [Parameter] public Major Major { get; set; }

    private Degree Degree;
    private List<List<TileData>> BlockedCourses;
    private int blockSize = 2;

    public TileData DragPayload { get; set; }
    public List<TileData> DragFrom { get; set; }

    public int ErrorCount { get; set; }
    public int WarningCount { get; set; }

    public async Task UpdateDegreePlanAsync(List<TileData> dragTo, TileData draggedOn)
    {
        Utilities.SwapValues(BlockedCourses, DragPayload, draggedOn);
        draggedOn.Status = 0;
        DragPayload.Status = 0;
        StateHasChanged();
    }

    protected override async Task OnParametersSetAsync()
    {
        var coreCourses = (await DegreeCourseService.GetCoreCoursesAsync(Degree.DegreeID)).Select(i => i.CourseID);
        var directedCourses = (await MajorCourseService.GetAllDirectedCoursesAsync(Major.MajorID)).Select(i => i.CourseID);

        var allCourses = await DegreeCourseService.GetCoreCoursesAsync(DegreeID);
        allCourses = allCourses.Concat(await MajorCourseService.GetCoreDirectedCoursesAsync(Major.MajorID));

        List<TileData> allCourseData = new List<TileData>();

        foreach (Course course in allCourses)
        {
            TileData td = new TileData();
            if (coreCourses.Contains(course.CourseID))
            {
                td.Course = course;
                td.TileType = TileType.Core;
            }
            else if (directedCourses.Contains(course.CourseID))
            {
                td.Course = course;
                td.TileType = TileType.Directed;
                td.IsDirectedCore = true;
            }
            allCourseData.Add(td);
        }

        while (allCourseData.Sum(t => t.Course.Units) < Degree.UnitLength)
        {
            TileData td = new TileData()
            {
                Course = null,
                TileType = TileType.Elective
            };
        }

        int countPerBlock = UnitsPerBlock / 10;

        Queue<TileData> cache = new Queue<TileData>(allCourseData.OrderBy(c => c.Course.CourseCode[4..]));

        // ALGORITHM

        BlockedCourses = new List<List<TileData>>();

        while (cache.Count > 0)
        {
            List<TileData> tempCourses = new List<TileData>();
            int loopCount = Math.Min(cache.Count, countPerBlock);
            for (int j = 0; j < loopCount; j++)
            {
                TileData tile = cache.Dequeue();
                List<Course> missingPrerequisites = await FindMissingPrerequisites(BlockedCourses, tile.Course);
                tile.Status = missingPrerequisites.Count > 0 ? ErrorStatus.Warning : 0;
                tempCourses.Add(tile);

                Console.WriteLine(tile.Course.CourseCode);
            }
            BlockedCourses.Add(tempCourses);
        }

    }

    private async Task<List<Course>> FindMissingPrerequisites(List<List<TileData>> courses, Course course)
    {
        List<Course> pCourses = (await CourseService.GetPrerequisiteCoursesAsync(course.CourseID)).ToList();

        List<Course> missing = new List<Course>();

        foreach(Course pCourse in pCourses)
        {
            if (!courses.Any(c => c.Any(i => i.Course.CourseID == pCourse.CourseID)))
            {
                missing.Add(pCourse);
            }
        }

        return missing;
    }


}
