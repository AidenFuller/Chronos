@inject DegreeCourseService DegreeCourseService
@inject CourseService CourseService
@inject MajorCourseService MajorCourseService
@inject IBlazorDownloadFileService DownloadService
@inject IToastService ToastService
@inject SaveState State

@using Newtonsoft.Json;

@using Chronos.Shared.Tiles;

@*<div class="year-label">
        <h7><b>Year 1</b></h7>
    </div>

    <div class="year-label">
        <h7><b>Year 2</b></h7>
    </div>*@
<CascadingValue Value="this">
    <div class="completedCourses" style="min-height: 20px; margin-bottom: 50px;">
        <TileSlot Tiles="@completedData" CompletedFlag="true" />
    </div>

    <div class="degreePlan">


        @*Pass boolean to determine if ghosts are showing to all children*@
        @if (State.CourseData == null)
        {
            <p>Loading...</p>
        }
        else
        {
            bool EOF = false;
            for (var enumerator = State.CourseData.GetEnumerator(); !EOF;)
            {
                <div class="year-row">
                    @for (int i = 0; i < State.BlocksPerYear; i++)
                    {
                        if (EOF = !enumerator.MoveNext())
                        {
                            break;
                        }
                        <p class="semester-label">Semester @(i + 1)</p>
                        <div class="semester">
                            @* Assuming Semesters *@

                            @if (i == 0)
                            {
                                //Semester 1
                                <TileSlot Tiles="@enumerator.Current" BlockType=@Models.Enums.CourseRuntime.Semester1 />
                            }
                            else
                            {
                                //Semester 2
                                <TileSlot Tiles="@enumerator.Current" BlockType=@Models.Enums.CourseRuntime.Semester2 />
                            }
                        </div>
                    }
                </div>
            }

            <br />

            <div>
                <div style="float:left">
                    <button @onclick="AddYear" class="btn-info">Add Year</button>
                </div>


                @*//-----------------------------------------------
                    //This button will remove the empty year
                    //----------------------------------------------*@

                <div style="float:right;">
                    <button @onclick="RemoveYear" class="btn-danger">Remove Year</button>
                </div>
            </div>

        }
    </div>
</CascadingValue>

<br />
<br />
<div class="json-save" @onclick=@(async () => await DownloadService.DownloadFileFromText("degree-plan.json", JsonConvert.SerializeObject(State), "application/octet-stream"))>
    Save
</div>


@code {
    // Cascaded Parameters
    public Degree Degree { get; private set; }
    public Major Major { get; private set; }
    public AvailableCampus Campus { get; private set; }


    private List<TileData> completedData;
    private int blockSize = 2;
    private bool fiftyUnitsWarningBool = false;

    //Dragging Variables
    public TileData DragPayload { get; set; }
    public List<TileData> DragFrom { get; set; }
    public CourseRuntime BlockTypeFrom { get; set; }


    public int ErrorCount { get; set; }
    public int WarningCount { get; set; }

    //Updates the degree plan after a drag
    public async Task UpdateDegreePlanAsync(List<TileData> dragTo, TileData draggedOn, CourseRuntime blockTypeTo)
    {
        if (DragPayload.Course is not null && (blockTypeTo & DragPayload.Runtime) == 0)
        {
            ToastService.ShowToast(ToastLevel.Error, $"{DragPayload.Course.CourseCode} does not run in {blockTypeTo}");
        }
        if (draggedOn.Course is not null && (BlockTypeFrom & draggedOn.Runtime) == 0)
        {
            ToastService.ShowToast(ToastLevel.Error, $"{draggedOn.Course.CourseCode} does not run in {BlockTypeFrom}");
        }
        if (((blockTypeTo & DragPayload.Runtime) > 0 || DragPayload.Course == null) && ((BlockTypeFrom & draggedOn.Runtime) > 0 || draggedOn.Course == null))
        {
            Utilities.SwapValues(State.CourseData, DragPayload, draggedOn);
            draggedOn.Status = 0;
            DragPayload.Status = 0;
            StateHasChanged();
        }
    }

    //Boolean to show the ghost tiles
    public bool ShowGhosts { get; set; } = false;
    //Show all ghost tiles in the plan
    public void ShowGhostTiles()
    {
        //Show a ghost tile in all places where the tile can be added
        ShowGhosts = true;
        StateHasChanged();
    }

    //Hide all ghost tiles in the plan
    public void HideGhostTiles()
    {
        //remove the ghost tiles
        ShowGhosts = false;
        StateHasChanged();
    }

    //Move payload from one slot to a new slot
    public void MovePayloadTo(TileSlot slot)
    {
        //Made design decision to handle this hear, saves intensive cascading parameters.
        //Leaving this note here as I may decide to change later.
        slot.Tiles.Add(DragPayload);
        DragFrom.Remove(DragPayload);
        DragPayload.Status = 0;
        FiftyUnitWarning(slot);
    }



    protected override async Task OnInitializedAsync()
    {
        Degree = State.Degree;
        Major = State.Major;
        Campus = State.Campus;
        //Query database
        List<TileData> allCourseData = new List<TileData>();
        List<Course> coreCourses = (await DegreeCourseService.GetCoreCoursesAsync(State.Degree.DegreeID)).ToList();

        List<Course> completedCourseValidator = new List<Course>(State.CompletedCourses);
        int completedUnitCount = 0;

        completedData = new List<TileData>();

        //Loop through pulled courses
        foreach (Course course in coreCourses)
        {
            TileData td = new TileData()
            {
                Course = course,
                TileType = TileType.Core,
                Runtime = await CourseService.GetCourseRuntimeAsync(course.CourseID, State.Campus)
            };

            int counter = completedCourseValidator.RemoveAll(c => c.CourseID == course.CourseID);
            if (counter > 0)
            {
                completedData.Add(td);
                completedUnitCount += counter;
            }
            else
            {
                allCourseData.Add(td);
            }
        }

        var coreDirectedCourses = await MajorCourseService.GetCompulsoryCoursesAsync(State.Major.MajorID);
        //Pull directed courses
        foreach (Course course in coreDirectedCourses)
        {
            TileData td = new TileData()
            {
                Course = course,
                TileType = TileType.Directed,
                IsDirectedCore = true,
                Runtime = await CourseService.GetCourseRuntimeAsync(course.CourseID, State.Campus)
            };

            int counter = completedCourseValidator.RemoveAll(c => c.CourseID == course.CourseID);
            if (counter > 0)
            {
                completedData.Add(td);
                completedUnitCount += counter;
            }
            else
            {
                allCourseData.Add(td);
            }
        }

        List<TileData> tempCache = new List<TileData>();


        //Create all empty directed
        int directedUnits = State.Degree.UnitLength - allCourseData.Sum(t => t.Course.Units) - completedData.Sum(t => t.Course.Units) - (State.Degree.ElectiveCount * 10);
        if (completedCourseValidator.Count > 0)
        {
            var nonCompulsoryCourses = await MajorCourseService.GetNonCompulsoryCoursesAsync(State.Major.MajorID);
            var courses = completedCourseValidator.Where(c => nonCompulsoryCourses.Any(n => n.CourseID == c.CourseID));
            if (courses.Count() > 0 && courses.Sum(t => t.Units) < directedUnits)
            {
                foreach (Course c in courses)
                {
                    TileData td = new TileData()
                    {
                        Course = c,
                        TileType = TileType.Directed,
                        Runtime = await CourseService.GetCourseRuntimeAsync(c.CourseID, State.Campus)
                    };
                    completedData.Add(td);
                }
                directedUnits -= courses.Sum(t => t.Units);
                completedCourseValidator.RemoveAll(c => courses.Any(comp => comp.CourseID == c.CourseID));
                
            }
            else if (courses.Count() > 0)
            {
                var tempCourses = new List<Course>();
                int i = 0;
                while (tempCourses.Sum(t => t.Units) < directedUnits)
                {
                    tempCourses.Add(courses.ElementAt(i++));
                }
                foreach (Course c in tempCourses)
                {
                    TileData td = new TileData()
                    {
                        Course = c,
                        TileType = TileType.Directed,
                        Runtime = await CourseService.GetCourseRuntimeAsync(c.CourseID, State.Campus)
                    };
                    completedData.Add(td);
                    completedCourseValidator.Remove(c);
                }
                directedUnits = 0;
            }

            foreach (Course c in completedCourseValidator)
            {
                TileData td = new TileData()
                {
                    Course = c,
                    TileType = TileType.Elective,
                    Runtime = await CourseService.GetCourseRuntimeAsync(c.CourseID, State.Campus)
                };
                completedData.Add(td);
            }
        }

        for (int i = 0; i < directedUnits; i += 10)
        {
            TileData td = new TileData()
            {
                Course = null,
                TileType = TileType.Directed
            };
            tempCache.Add(td);
        }

        //Create all empty elective courses
        // Add excess for the number of completed courses
        for (int i = 0; i < State.Degree.ElectiveCount - completedCourseValidator.Count + State.CompletedCourses.Count; i++)
        {
            TileData td = new TileData()
            {
                Course = null,
                TileType = TileType.Elective
            };
            tempCache.Add(td);
        }

        //Add them to plan
        allCourseData.AddRange(tempCache);

        List<TileData> cache = allCourseData.OrderBy(c => c.Course?.CourseCode[4..] ?? "9999").ToList();

        output = SetupStructure(State.RuntimeStart == CourseRuntime.Semester2);

        int n = State.RuntimeStart == CourseRuntime.Semester2 ? 1 : 0;

        if (await Autocomplete(cache, n))
        {
            for (int i = 0; i < output.Count; i++)
            {
                output[i] = output[i].OrderBy(c => c.Course?.CourseCode ?? "ZZZZ9999").ToList();
            }

            int total = State.CompletedCourses.Count;
            foreach(List<TileData> tiles in output)
            {
                if (total == 0)
                    break;
                for (int i = tiles.Count - 1; i >= 0; i--)
                {
                    if (total == 0)
                        break;
                    if (tiles[i].TileType == TileType.Elective)
                    {
                        tiles.RemoveAt(i);
                        total--;
                    }
                }
            }

            State.CourseData = output;
        }
        else
        {
            // Throw toast error
        }

        //Parameters set, modify as needed
        

    }

    //Returns a list of missing prerequisite courses
    private async Task<List<Course>> FindMissingPrerequisites(List<List<TileData>> courses, Course course)
    {
        List<Course> pCourses = (await CourseService.GetPrerequisiteCoursesAsync(course.CourseID)).ToList();

        List<Course> missing = new List<Course>();

        foreach (Course pCourse in pCourses)
        {
            if (!courses.Any(c => c.Any(i => i.Course.CourseID == pCourse.CourseID)))
            {
                missing.Add(pCourse);
            }
        }

        return missing;
    }

    //Returns all courses in the plan
    public IEnumerable<Course> getAllCourses()
    {
        IEnumerable<Course> allC = new List<Course>();

        foreach (List<TileData> sem in State.CourseData)
        {
            foreach (TileData td in sem)
            {
                allC.Append(td.Course);
            }
        }

        return allC;
    }

    public void FiftyUnitWarning(TileSlot slot)
    {
        if (slot.Tiles.Sum(c => c.Course?.Units ?? 10) == 50 && !fiftyUnitsWarningBool) //Change 50 to readonly total in later branch.
        {
            RenderFragment message =
    @<text>By including 50 units in a semester, you will have to go to the UON website and follow instructions in order to enrol in 50 units. Find it here at this link: <a href="https://askuon.newcastle.edu.au/app/answers/detail/a_id/1764/~/can-i-enrol-in-more-than-40-units-in-a-semester%3F">Click Here</a> </text>;
            ToastService.ShowToast(ToastLevel.Warning, message);
            fiftyUnitsWarningBool = true;
        }
    }
    //Returns true if the plan contains the course
    public bool ContainsCourse(Course course)
    {
        return State.CourseData.Any(sem => sem.Any(c => (c.Course?.CourseID ?? -1) == course.CourseID));
    }

    private List<List<TileData>> SetupStructure(bool sem2Start)
    {
        int yearCount = State.Degree.UnitLength / (State.UnitsPerBlock * State.BlocksPerYear);
        if (sem2Start)
            yearCount++;


        List<List<TileData>> toReturn = new List<List<TileData>>();

        for (int i = 0; i < yearCount; i++)
        {
            toReturn.Add(new List<TileData>());
            toReturn.Add(new List<TileData>());
        }

        return toReturn;
    }


    private List<List<TileData>> output;

    /// <summary>
    /// THE MAIN ALGORITHM
    /// </summary>
    private async Task<bool> Autocomplete(List<TileData> cache, int n)
    {
        if (cache.Count == 0)
            return true;

        int index = 0;
        bool flag = false;
        do
        {
            TileData td = cache[index++];
            if (output[n].Sum(c => c.Course?.Units ?? 10) >= State.UnitsPerBlock)
                n++;

            if (n >= State.Degree.UnitLength / State.UnitsPerBlock + (State.RuntimeStart == CourseRuntime.Semester2 ? 1 : 0))
                return false;

            while (!await ValidateCourse(td, n))
            {
                if (index == cache.Count)
                    return false;
                td = cache[index++];
            }

            //DisplayOutput();
            output[n].Add(td);
            if (StateHasAppeared())
            {
                output[n].Remove(td);
            }
            else
            {
                cache.RemoveAt(index - 1);
                flag = await Autocomplete(new List<TileData>(cache), n);
                if (!flag)
                {
                    output[n].Remove(td);
                }
                cache.Insert(index - 1, td);
            }
        }
        while (!flag && index < cache.Count);

        return flag;
    }

    private async Task<bool> ValidateCourse(TileData td, int n)
    {
        bool flag = true;

        int groupNumber = (n - (State.RuntimeStart == CourseRuntime.Semester2 ? 1 : 0)) / 2 + 1;

        int minDirectedGroup = int.Parse((await MajorCourseService.GetAllDirectedCoursesAsync(State.Major.MajorID)).ToList().Min(c => c.CourseCode[4]).ToString());

        if (td.Course == null)
        {
            if (td.TileType == TileType.Directed && minDirectedGroup <= groupNumber)
                return true;
            else if (td.TileType == TileType.Elective)
                return true;
            else
                return false;
        }

        if (n % 2 == 0 && (td.Runtime & CourseRuntime.Semester1) == 0)
            flag = false;
        else if (n % 2 == 1 && (td.Runtime & CourseRuntime.Semester2) == 0)
            flag = false;
        else if (n > 0 && td.Course.CourseCode == "COMP3851B" && !output[n - 1].Any(c => (c.Course?.CourseCode ?? "lmfao") == "COMP3851A"))
            flag = false;
        else if (int.Parse(td.Course.CourseCode[4].ToString()) > groupNumber)
            flag = false;
        else if (!await CheckPrerequisites(td, n))
            flag = false;

        return flag;
    }

    private void DisplayOutput()
    {
        int n = 0;
        foreach (List<TileData> block in output)
        {
            Console.Write("|");
            foreach (TileData td in block)
            {
                Console.Write(" ");
                Console.Write(td.Course?.CourseCode ?? "Blank");
                Console.Write(" ");
            }
            Console.Write("|");
            if (n++ % 2 == 1)
                Console.WriteLine();
        }
    }

    private List<int> states = new List<int>();
    private bool StateHasAppeared()
    {
        int hash = EncodeOutput();
        if (states.Contains(hash))
            return true;
        states.Add(hash);
        return false;
    }

    private int EncodeOutput()
    {
        string hashStr = "";
        foreach (List<TileData> block in output)
        {
            foreach (TileData td in block.OrderBy(c => c.Course?.CourseCode ?? "9999"))
            {
                if (td.Course != null)
                {
                    hashStr += td.Course.CourseCode;
                }
                else
                {
                    hashStr += "BLANK";
                }
            }
        }
        return hashStr.GetHashCode();
    }

    private async Task<bool> CheckPrerequisites(TileData tile, int n)
    {
        if (tile.Course == null)
            return true;

        var courseList = (await CourseService.GetPrerequisiteCoursesAsync(tile.Course.CourseID)).ToList();

        int tally = 0;
        for (int i = 0; i < n; i++)
        {
            tally += courseList.Count(c => output[i].Any(t => t.Course?.CourseCode == c.CourseCode));
        }

        tally += courseList.Count(c => State.CompletedCourses.Any(completedCourse => completedCourse.CourseCode == c.CourseCode));

        return tally == courseList.Count();
    }

    private void AddYear()
    {
        State.CourseData.Add(new List<TileData>());
        State.CourseData.Add(new List<TileData>());
        StateHasChanged();
    }

    private void RemoveYear()
    {
        //----------------------------------------
        //Count the total number of rows(semester tiles)
        //Check if total tiles is greater than 1
        //Remove the last index from the total tile
        //----------------------------------------

        if (State.CourseData.Count >= 2)
        {
            if (State.CourseData[^1].Count == 0 && State.CourseData[^2].Count == 0)

            {
                State.CourseData.RemoveAt(State.CourseData.Count - 1);
                State.CourseData.RemoveAt(State.CourseData.Count - 1);
            }


        }

        StateHasChanged(); //Will update in all the components
    }
}

