@inject DegreeCourseService DegreeCourseService
@inject CourseService CourseService 
@inject MajorCourseService MajorCourseService
@inject IBlazorDownloadFileService DownloadService 
@using Newtonsoft.Json;  

@using Chronos.Shared.Tiles;

<div class="year-label">
    <h7><b>Year 1</b></h7>
</div>

<div class="year-label">
    <h7><b>Year 2</b></h7>
</div>

<div class="degreePlan">
    <CascadingValue Value="this">
        @*Pass boolean to determine if ghosts are showing to all children*@
        @if (courseData == null)
        {
            <p>Loading...</p>
        }
        else
        {
            for (int j = 0; j < (courseData.Count + 1) / BlocksPerYear; j++)
            {
                <div class="year-row">
                    @for (int i = 0; i < BlocksPerYear; i++)
                    {
                        <h6 class="semester-label">Semester @(i + 1)</h6>
                        if (i + (j * BlocksPerYear) >= courseData.Count)
                        {
                            continue;
                        }
                        <div class="semester">
                            @* Assuming Semesters *@

                            @if (i == 0)
                            {
                                //Semester 1
                                <TileSlot Tiles="@courseData[i+(j*BlocksPerYear)]" BlockType=@Models.Enums.CourseRuntime.Semester1/>
                            }
                            else
                            {
                                //Semester 2
                                <TileSlot Tiles="@courseData[i+(j*BlocksPerYear)]" BlockType=@Models.Enums.CourseRuntime.Semester2/>
                            }

                        </div>
                    }
                </div>
            }
        }
    </CascadingValue>
</div>

<div class="json-save" @onclick=@(async () => await DownloadService.DownloadFileFromText("degree-plan.json", Serialize(), "application/octet-stream"))>
    Save
</div>


@code {
    //Parameters
    [Parameter] public int BlocksPerYear { get; set; } = 2;
    [Parameter] public int UnitsPerBlock { get; set; } = 40;
    [Parameter] public Degree Degree { get; set; }
    [Parameter] public Major Major { get; set; }
    [Parameter] public List<Course> CompletedCourses { get; set; }
    [Parameter] public AvailableCampus Campus { get; set; }
    [Parameter] public string JSON { get; set; } = null;

    private List<List<TileData>> courseData;
    private int blockSize = 2;

    //Dragging Variables
    public TileData DragPayload { get; set; }
    public List<TileData> DragFrom { get; set; }
    public CourseRuntime BlockTypeFrom { get; set; }


    public int ErrorCount { get; set; }
    public int WarningCount { get; set; }

    //Updates the degree plan after a drag
    public async Task UpdateDegreePlanAsync(List<TileData> dragTo, TileData draggedOn, CourseRuntime blockTypeTo)
    {
        if (((blockTypeTo & DragPayload.Runtime) > 0 || DragPayload.Course == null) && ((BlockTypeFrom & draggedOn.Runtime) > 0 || draggedOn.Course == null))
        {
            Utilities.SwapValues(courseData, DragPayload, draggedOn);
            draggedOn.Status = 0;
            DragPayload.Status = 0;
            StateHasChanged();
        }
    }

    //Boolean to show the ghost tiles
    public bool ShowGhosts { get; set; } = false;
    //Show all ghost tiles in the plan
    public void ShowGhostTiles()
    {
        //Show a ghost tile in all places where the tile can be added
        ShowGhosts = true;
        StateHasChanged();
    }

    //Hide all ghost tiles in the plan
    public void HideGhostTiles() {
        //remove the ghost tiles
        ShowGhosts = false;
        StateHasChanged();
    }

    //Move payload from one slot to a new slot
    public void MovePayloadTo(TileSlot slot)
    {
        //Made design decision to handle this hear, saves intensive cascading parameters.
        //Leaving this note here as I may decide to change later.
        slot.Tiles.Add(DragPayload);
        DragFrom.Remove(DragPayload);
        DragPayload.Status = 0;
    }



    protected override async Task OnParametersSetAsync()
    {
        //JSON Management
        if (JSON != null)
        {
            //JSON Input
            SaveState state = JsonConvert.DeserializeObject<SaveState>(JSON);
            courseData = state.CourseData;
            BlocksPerYear = state.BlocksPerYear;
            UnitsPerBlock = state.UnitsPerBlock;
            Degree = state.Degree;
            Major = state.Major;
            CompletedCourses = state.CompletedCourses;
            Campus = state.Campus;
        }
        else
        {
            //Manaul input

            //Query database
            List<TileData> allCourseData = new List<TileData>();
            List<Course> coreCourses = (await DegreeCourseService.GetCoreCoursesAsync(Degree.DegreeID)).ToList();

            //Loop through pulled courses
            foreach (Course course in coreCourses)
            {
                //Create a tile data and add to list
                TileData td = new TileData()
                {
                    Course = course,
                    TileType = TileType.Core,
                    Runtime = await CourseService.GetCourseRuntimeAsync(course.CourseID, Campus)
                };

                allCourseData.Add(td);
            }

            var coreDirectedCourses = await MajorCourseService.GetCompulsoryCoursesAsync(Major.MajorID);
            //Pull directed courses
            foreach (Course course in coreDirectedCourses)
            {
                //Add to list
                TileData td = new TileData()
                {
                    Course = course,
                    TileType = TileType.Directed,
                    IsDirectedCore = true,
                    Runtime = await CourseService.GetCourseRuntimeAsync(course.CourseID, Campus)
                };

                allCourseData.Add(td);
            }

            /*
            foreach (Course course in allCourses)
            {
                TileData td = new TileData();
                if (coreCourses.Contains(course.CourseID))
                {
                    td.Course = course;
                    td.TileType = TileType.Core;
                }
                else if (directedCourses.Contains(course.CourseID))
                {
                    td.Course = course;
                    td.TileType = TileType.Directed;
                    td.IsDirectedCore = true;
                }
                allCourseData.Add(td);
            }

            */
            //Console.WriteLine(allCourseData.Any(t => t.Course == null));

            List<TileData> tempCache = new List<TileData>();

            //Create all empty directed
            for (int i = 0; i < Degree.UnitLength - allCourseData.Sum(t => t.Course.Units) - (Degree.ElectiveCount * 10); i += 10)
            {
                TileData td = new TileData()
                {
                    Course = null,
                    TileType = TileType.Directed
                };
                tempCache.Add(td);
            }

            //Create all empty elective courses
            for (int i = 0; i < Degree.ElectiveCount; i++)
            {
                TileData td = new TileData()
                {
                    Course = null,
                    TileType = TileType.Elective
                };
                tempCache.Add(td);
            }

            //Add them to plan
            allCourseData.AddRange(tempCache);

            Queue<TileData> cache = new Queue<TileData>(allCourseData);

            // ALGORITHM -- TBD

            courseData = new List<List<TileData>>();

            List<TileData> tempCourses = new List<TileData>();

            while (cache.Count > 0)
            {
                if (tempCourses.Sum(t => (t.Course?.Units ?? 10)) >= UnitsPerBlock)
                {
                    courseData.Add(tempCourses);
                    tempCourses = new List<TileData>();
                }

                TileData tile = cache.Dequeue();
                //List<Course> missingPrerequisites = await FindMissingPrerequisites(BlockedCourses, tile.Course);
                //tile.Status = missingPrerequisites.Count > 0 ? ErrorStatus.Warning : 0;

                tempCourses.Add(tile);
                //Console.WriteLine(tile.Course.CourseCode);
            }
            courseData.Add(tempCourses);
        }
    }

    //Returns a list of missing prerequisite courses
    private async Task<List<Course>> FindMissingPrerequisites(List<List<TileData>> courses, Course course)
    {
        List<Course> pCourses = (await CourseService.GetPrerequisiteCoursesAsync(course.CourseID)).ToList();

        List<Course> missing = new List<Course>();

        foreach (Course pCourse in pCourses)
        {
            if (!courses.Any(c => c.Any(i => i.Course.CourseID == pCourse.CourseID)))
            {
                missing.Add(pCourse);
            }
        }

        return missing;
    }

    //Returns all courses in the plan
    public IEnumerable<Course> getAllCourses()
    {
        IEnumerable <Course> allC = new List<Course>();

        foreach(List<TileData> sem in courseData)
        {
            foreach(TileData td in sem)
            {
                allC.Append(td.Course);
            }
        }

        return allC;
    }

    //Returns true if the plan contains the course
    public bool ContainsCourse(Course course)
    {
        return courseData.Any(sem => sem.Any(c => (c.Course?.CourseID ?? -1) == course.CourseID));
    }


    //Returns string Serialized for JSON
    private string Serialize()
    {
        SaveState state = new SaveState()
        {
            Campus = this.Campus,
            CompletedCourses = this.CompletedCourses,
            Degree = this.Degree,
            BlocksPerYear = this.BlocksPerYear,
            CourseData = this.courseData,
            Major = this.Major,
            UnitsPerBlock = this.UnitsPerBlock
        };

        return JsonConvert.SerializeObject(state);
    }
}
